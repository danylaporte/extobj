//! # extobj
//!
//! A tiny, zero-cost library that lets you **extend a struct with new fields
//! across crate boundaries** without recompiling upstream crates.
//!
//! ## Quick start
//!
//! ```
//! use extobj::{extobj, ExtObj};
//!
//! // 1. Declare the extension object type.
//! extobj!(pub struct Player);
//!
//! // 2. In any downstream crate add fields.
//! extobj!(impl Player {
//!     pub health: i32,
//!     pub level:  u32,
//! });
//!
//! // 3. Use it.
//! let mut p = ExtObj::<Player>::new();
//! p[*health] = 100;
//! p[*level]  = 5;
//! assert_eq!(p[*health], 100);
//! ```
//!
//!
//! ## How it works
//!
//! Every field becomes a `static Var<Player, T>` singleton.  
//! `ExtObj<Player>` is a grow-only vector whose slot *i* stores a `T`
//! created by the corresponding `Var`.  Construction / destruction are routed
//! through an internal v-table generated by the macro.  All public APIs are
//! safe; the unsafe internals are confined to the crate.
//!
//! ## Optional crate rename
//!
//! ```
//! extobj::extobj!(struct Foo, crate_path = extobj);
//! extobj::extobj!(impl Foo { M: u8 }, crate_path = extobj);
//! ```
//!
//! ## Optional init code
//!
//! ```
//! extobj::extobj!(struct Foo);
//! extobj::extobj!(impl Foo { M: u8 }, init = register_deps());
//!
//! fn register_deps() {
//!     // do some init code here.
//! }
//! ```
//!
//! ## Cargo features
//!
//! None â€“ only depends on `std`.

#![warn(missing_docs)]
#![allow(non_camel_case_types)] // used by the macro-generated marker types

mod dynobj;

pub use ctor;
pub use dynobj::DynObj;
pub use extobj_macro::extobj;
use std::{
    fmt::{self, Debug, Formatter},
    hash::{Hash, Hasher},
    marker::PhantomData,
    ops::{Index, IndexMut},
};

#[doc(hidden)]
pub type Defs = std::sync::RwLock<Vec<(unsafe fn() -> usize, unsafe fn(usize))>>;

/// # Note
/// This trait is for used only in macros.
#[doc(hidden)]
pub trait __ExtObjDef: 'static {
    fn defs() -> &'static Defs;
}

/// An extendable struct that be extented across crate.
pub struct ExtObj<O: __ExtObjDef>(Vec<usize>, PhantomData<O>);

impl<O: __ExtObjDef> ExtObj<O> {
    /// Creates a new, empty `ExtObj` with every registered field initialized to its
    /// default value.
    pub fn new() -> Self {
        Self(
            O::defs()
                .read()
                .unwrap()
                .iter()
                .map(|(f, _)| unsafe { f() })
                .collect(),
            PhantomData,
        )
    }

    /// Immutably borrows the value of the given variable.
    #[inline]
    pub fn get<T>(&self, var: Var<O, T>) -> &T {
        unsafe { &*(*self.0.get_unchecked(var.0) as *const T) }
    }

    /// Mutably borrows the value of the given variable.
    #[inline]
    pub fn get_mut<T>(&mut self, var: Var<O, T>) -> &mut T {
        unsafe { &mut *(*self.0.get_unchecked(var.0) as *mut T) }
    }
}

impl<O: __ExtObjDef> Default for ExtObj<O> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

impl<O: __ExtObjDef> Drop for ExtObj<O> {
    fn drop(&mut self) {
        // single, shared read-lock
        let defs = O::defs().read().unwrap();
        let defs = defs.as_slice();

        // SAFETY: both slices have identical length
        unsafe {
            for i in 0..self.0.len() {
                let ptr = *self.0.get_unchecked(i);
                let (_, drop_fn) = *defs.get_unchecked(i);
                drop_fn(ptr);
            }
        }
    }
}

impl<O: __ExtObjDef, T> Index<Var<O, T>> for ExtObj<O> {
    type Output = T;

    #[inline]
    fn index(&self, index: Var<O, T>) -> &Self::Output {
        self.get(index)
    }
}

impl<O: __ExtObjDef, T> IndexMut<Var<O, T>> for ExtObj<O> {
    #[inline]
    fn index_mut(&mut self, index: Var<O, T>) -> &mut Self::Output {
        self.get_mut(index)
    }
}

/// A typed handle to one field in an `ExtObj<O>`.
///
/// Values of this type are produced by the `extobj!` macro and are normally
/// used as `static` items.
#[repr(transparent)]
pub struct Var<O, T>(usize, PhantomData<(O, T)>);

impl<O, T> Var<O, T> {
    /// Erase the type of the variable and extract the information representing this
    /// variable in the extobj type.
    #[inline]
    pub fn var_id(self) -> VarId<O> {
        VarId(self.0, PhantomData)
    }
}

impl<O, T> Clone for Var<O, T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}

impl<O, T> Copy for Var<O, T> {}

impl<O, T> Debug for Var<O, T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_tuple("Var").field(&self.0).finish()
    }
}

impl<O, T> Eq for Var<O, T> {}

impl<O, T> Hash for Var<O, T> {
    #[inline]
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl<O, T> PartialEq for Var<O, T> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl<O: __ExtObjDef, T: Default + 'static> Var<O, T> {
    #[doc(hidden)]
    pub fn __new() -> Self {
        let mut defs = O::defs().write().unwrap();
        let index = defs.len();

        defs.push((init_default::<T>, dropper::<T>));

        Self(index, PhantomData)
    }
}

unsafe fn init_default<T: Default>() -> usize {
    Box::into_raw(Box::new(T::default())) as usize
}

unsafe fn dropper<T>(ptr: usize) {
    unsafe {
        drop(Box::from_raw(ptr as *mut T));
    }
}

/// The variable identifier inside the extobj. This can be hashed.
pub struct VarId<O>(usize, PhantomData<O>);

impl<O> Clone for VarId<O> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}

impl<O> Copy for VarId<O> {}

impl<O> Debug for VarId<O> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_tuple("VarId").field(&self.0).finish()
    }
}

impl<O> Eq for VarId<O> {}

impl<O> Hash for VarId<O> {
    #[inline]
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl<O> PartialEq for VarId<O> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl<O, T> PartialEq<Var<O, T>> for VarId<O> {
    #[inline]
    fn eq(&self, other: &Var<O, T>) -> bool {
        self.0 == other.0
    }
}

impl<O, T> PartialEq<VarId<O>> for Var<O, T> {
    #[inline]
    fn eq(&self, other: &VarId<O>) -> bool {
        self.0 == other.0
    }
}
